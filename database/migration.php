<?php

use SnooPHP\Model\Db;
use SnooPHP\Model\Table;

/******************
 * MIGRATION SCRIPT
 ******************/

// Terminal colors

/**
 * @var Table[] $tables list of tables registered for migration
 */
$tables = [];

/**
 * Run migration on table set
 * 
 * The migration script compare tables with previous migration.
 * If a migration associated with the current table exists
 * changes are computed and applied, otherwise a new table is created.
 * In any case the new table is serialized and saved as a migration file
 * or an error is output.
 * 
 * @param string $schema schema to use
 */
function migrate_all($schema = "master")
{
	global $tables;

	// Compute dependencies to avoid conflicts
	$tables = compute_dependencies($tables);

	echo "> starting migration ...\n";

	foreach($tables as $table)
	{
		$name			= $table->name();
		$migrationFile	= __DIR__."/migrated/$schema/$name.tab";
		$status			= true;

		echo "\n=== ".strtoupper($name)." ===\n";

		// Start transaction
		Db::beginTransaction($schema);

		// If migration file exists
		// Run migration process
		if ($filename = realpath($migrationFile))
		{
			echo "> processing existing table \e[1;37m'$name'\e[0m:\n";

			$old	= unserialize(read_file($filename));
			$status	= $table->migrate($old, $schema);
		}
		// Else create new table
		else
		{
			echo "> creating new table \e[1;37m'$name'\e[0m:\n";
			echo "\n{$table->createQuery()}\n\n";
			
			$status = $table->create($schema);
		}

		if ($status)
		{
			echo "\e[1;32m✓\e[0m all ok\n";
			echo "> saving migration file\n";

			if (write_file($migrationFile, $table, true, true))
			{
				// Commit changes
				Db::commit($schema);
				echo "\e[1;32m✓\e[0m migration saved at $migrationFile\n";
			}
			else
			{
				// Undo all changes
				Db::rollback($schema);
				echo "\e[1;31m!\e[0m error while saving migration; changes to table not applied\n";
			}
		}
		else
		{
			// Undo all changes to database
			Db::rollback($schema);
			echo "\e[1;31m!\e[0m something went wrong, check table definition\n";
		}
	}
}

/**
 * Drop all tables
 * 
 * @param string $schema schema to use
 * 
 * @return bool false if fails
 */
function drop_all($schema = "master")
{
	// Drop existing tables
	$migrationFiles = glob(__DIR__."/migrated/$schema/*.tab");

	if (count($migrationFiles) > 0)
	{
		// Retrieve migrated tables
		$migrations = [];
		foreach($migrationFiles as $migrationFile)
		{
			$migration = unserialize(read_file($migrationFile));
			$migration->generateDependencies();
			$migrations[] = $migration;
		}

		// Compute reverse dependencies order
		$migrations = array_reverse(compute_dependencies($migrations));

		echo "> dropping tables ...\n";

		foreach($migrations as $migration)
		{
			echo "    ➤ ".$migration->name()."\n";
			$tableNames[] = $migration->name();
		}

		// Begin transaction
		Db::beginTransaction();
		$status = Db::query("drop table if exists ".implode(",", $tableNames)) !== false;

		if ($status)
		{
			// Remove migration files
			foreach($migrationFiles as $migrationFile) unlink($migrationFile);

			// Commit changes
			Db::commit();
			echo "\e[1;32m✓\e[0m tables dropped\n\n";
			return true;
		}
		else
		{
			// Undo all changes
			Db::rollback();
			echo "\e[1;31m!\e[0m something went wrong ...\n\n";
			return false;
		}
	}
	
	// No table was dropped
	return true;
}

/**
 * Drop all and migrate
 * 
 * @param string $schema schema to use
 */
function reset_all($schema = "master")
{
	// Drop and migrate
	if (drop_all($schema)) migrate_all($schema);
}

/**
 * Compute migration order to avoid collisions between tables
 * 
 * This function takes into account table dependencies
 * and reorders the table list in order to avoid collisions between tables.
 * Errors are usually generated by foreign key constraints
 * that reference tables non created yet.
 * Circular dependency or missing references may result in an infinite loop.
 * 
 * @param array $tables tables to reorder;
 * 
 * @return array ordered tables
 */
function compute_dependencies(array $tables)
{
	echo "> computing tables dependencies ...\n";

	/**
	 * @todo should check for missing references and circular dependencies
	 */

	$order = [];
	while (!empty($tables))
		// Move tables that are dependency free in order list
		foreach ($tables as $i => $table)
			if (!$table->dependent())
			{
				$order[] = $table;
				echo "    ➤ {$table->name()}\n";

				unset($tables[$i]);
				foreach ($tables as $t) $t->removeDependency($table->name());
			}

	// Return new order
	echo "\e[1;32m✓\e[0m dependencies computed!\n";
	echo "------------------------\n";
	return $order;
}

/**
 * Add table to list and generate its dependencies
 * 
 * @param Table $table table to add
 */
function register_table(Table $table)
{
	global $tables ;
	// Generate table dependencies
	$table->generateDependencies();
	$tables[] = $table;
}